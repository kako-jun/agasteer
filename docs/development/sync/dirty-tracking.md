## 未保存変更の確認機能

### 概要

GitHubにPushされていない変更がある状態で、データを失う可能性のある操作を行う際に確認ダイアログを表示します。

### ダーティフラグ管理

#### isDirtyストア

GitHubにPushされていない変更があるかどうかを追跡するストア。LocalStorageに永続化することで、PWA強制終了後も未保存状態を検出できます。

**LocalStorage永続化の目的:**

PWAがOSによってバックグラウンドで強制終了された場合、`beforeunload`イベントが発火しません。この場合、メモリ上の`isDirty`フラグは失われますが、LocalStorageに永続化することで、再起動後も未保存状態を検出できます。

#### ダーティが検出されるタイミング

スナップショット比較方式により、以下のタイミングで自動的に差分が検出されます：

1. **ノート更新時**: `updateNotes()`関数内で`updateHomeDirtyIds()`が自動実行
2. **リーフ更新時**: `updateLeaves()`関数内で`updateHomeDirtyIds()`が自動実行

これらの関数は現在の状態と`lastPushedNotes`/`lastPushedLeaves`を比較し、変更があれば`dirtyNoteIds`/`dirtyLeafIds`に追加します。

**対象操作:**

- ノート/リーフの作成、削除、名前変更、並び替え
- リーフのコンテンツ編集

#### ダーティフラグがクリアされるタイミング

1. **Push成功時**: GitHubへの保存が完了
2. **Pull成功時**: GitHubと同期が完了

### 確認ダイアログの表示

#### 1. アプリ起動時（初回Pull）

アプリ起動時は「自動的にPullボタンを押す」のと同じです。handlePull内でダーティチェック、staleチェックが行われます。

**handlePull関数のパラメータ:**

- **isInitialStartup**: trueの場合、確認ダイアログのメッセージが起動時用に変わる
- **onCancel**: 確認ダイアログでキャンセルした時に呼ばれるコールバック

**起動時のキャンセル動作:**

- 操作ロックを解除
- IndexedDBからノート・リーフを読み込んでストアに設定
- URLから状態を復元
- これにより、PWA強制終了後でもローカルの変更を保持して継続編集が可能

#### 2. Pullボタンクリック時

Pullボタンと初回Pullは同じhandlePull関数を使用します。ダーティチェックとstaleチェックを行い、必要に応じて確認ダイアログを表示します。

**処理フロー:**

1. 交通整理: Pull/Push中は不可
2. 未保存の変更がある場合は確認ダイアログ
3. staleチェック（変更がなければ「変更なし」通知）
4. Pull実行

**確認ダイアログ:**

- **ダイアログタイプ**: Modal.svelteベースの既存モーダル
- **メッセージ（通常）**: 「未保存の変更があります。Pullすると上書きされます。続行しますか？」
- **メッセージ（起動時）**: 「前回の編集内容がGitHubに保存されていません。Pullすると失われます。Pullしますか？」

#### 3. ページ離脱時（ブラウザ標準ダイアログ）

タブを閉じる、リロード、外部サイトへの移動時に`beforeunload`イベントで確認ダイアログを表示。

- **ダイアログタイプ**: ブラウザ標準の確認ダイアログ
- **メッセージ**: ブラウザが自動生成（「変更が保存されていない可能性があります」など）

### 視覚的なフィードバック

#### 保存ボタンへのダーティマーク

未保存の変更がある場合、保存ボタンに赤い丸印（notification badge）を表示。

| 項目     | 値               |
| -------- | ---------------- |
| 表示位置 | 保存ボタンの右上 |
| サイズ   | 8x8px            |
| 色       | #ef4444（赤色）  |
| 形状     | 円形             |

### アプリ内ナビゲーションは制限されない

このアプリは編集時に自動的にIndexedDBに保存されるため、アプリ内のナビゲーション（ホーム、ノート、リーフ間の移動）ではデータが失われません。

**確認が不要な操作:**

- ホームへの移動
- ノート/リーフの選択
- ブラウザの戻る/進むボタン
- ノート/リーフの作成、削除、名前変更、並び替え

**確認が必要な操作:**

- **Pull実行**: GitHubのデータでIndexedDBを上書きするため
- **ページ離脱**: ブラウザのタブを閉じる、リロード、外部サイトへの移動

ダーティフラグは「GitHubにPushしていない」という意味であり、GitHubとの同期を失う操作のみ確認が必要です。

### 動作フロー

#### 通常フロー

1. **リーフを編集** → `updateLeaves()`で差分検出 → `dirtyLeafIds`に追加 → LocalStorageに永続化 → 保存ボタンに赤い丸印表示
2. **Pushボタンをクリック** → Push実行 → 成功時に `setLastPushedSnapshot()` + `clearAllChanges()` → LocalStorageから削除 → 赤い丸印消える
3. **未保存の状態でPullボタンをクリック** → 確認ダイアログ表示
4. **未保存の状態でタブを閉じる** → ブラウザ標準の確認ダイアログ表示

#### PWA強制終了フロー

```
PWA強制終了 (isDirty=true のままLocalStorageに残る)
    ↓
PWA再起動
    ↓
onMount: LocalStorageからisDirty=trueを検出
    ↓
確認ダイアログ表示
    ├─ OK → Pull実行（GitHubの最新に上書き、ローカル変更は破棄）
    └─ キャンセル → IndexedDBから読み込み、操作可能に（Pushすればローカル変更を保存可能）
```

---

## リーフごとのダーティ追跡

### 概要

リーフ単位で未保存の変更を追跡し、UIに赤丸で表示します。これにより、ユーザーはどのリーフが未保存なのかを一目で把握できます。

### 設計思想

ダーティ判定は**スナップショット比較方式**を採用しています。最後にPush/Pullした状態と現在の状態を比較することで、変更を検出します。

**メリット:**

- 1文字打って1文字消しても、元に戻ればダーティが消える
- フラグの設定忘れ・クリア忘れがそもそも起きない
- ノートと同じ仕組みで一貫性がある

### ストア構成

| ストア           | 説明                                                                   |
| ---------------- | ---------------------------------------------------------------------- |
| dirtyLeafIds     | コンテンツ変更があったリーフIDのSet（スナップショット比較）            |
| dirtyNoteIds     | 構造変更があったノートIDのSet（スナップショット比較）                  |
| isStructureDirty | フォールバック用フラグ（PWA復元時など特殊ケース用）                    |
| isDirty          | 全体のダーティ判定（dirtyLeafIds or dirtyNoteIds or isStructureDirty） |

### ヘルパー関数

| 関数名                | 説明                                        |
| --------------------- | ------------------------------------------- |
| clearAllChanges       | 全変更をクリア（Push/Pull成功時に呼び出し） |
| isNoteDirty           | 特定ノート配下のリーフがダーティかどうか    |
| setLastPushedSnapshot | Push/Pull成功時にスナップショットを保存     |

### UI表示

- **リーフカードの赤丸**: リーフタイトルの横に表示（`$dirtyLeafIds.has(leaf.id)`）
- **ノートカードの赤丸**: 配下にダーティなリーフがある、または構造変更がある場合に表示

### ダーティ検出のタイミング

1. **ストア更新時**: `updateLeaves()`内で`updateHomeDirtyIds()`が自動実行
2. **差分検出**: 現在のリーフと`lastPushedLeaves`を比較し、コンテンツが異なるリーフを`dirtyLeafIds`に追加

### ダーティがクリアされるタイミング

1. **Push成功時**: `setLastPushedSnapshot()` + `clearAllChanges()`
2. **Pull成功時**: `setLastPushedSnapshot()` + `clearAllChanges()`
3. **編集を元に戻した時**: スナップショットと同じ状態になれば自動的にクリア

---

## スナップショットベースの差分検出

### 概要

ノートやリーフの構造的な変更（作成、削除、移動、名前変更など）を検出するために、最後にPush/Pullした状態のスナップショットと現在の状態を比較します。これにより、どのノートに変更があるかを自動的に特定し、UIに赤丸を表示できます。

### 設計思想

以前は構造変更のたびに手動で`addDirtyNoteId()`を呼び出していましたが、この方式には以下の問題がありました：

- **抜け漏れのリスク**: 21箇所以上に分散した呼び出しで、新機能追加時に漏れる可能性
- **保守性の低下**: 変更箇所が多く、コードレビューが困難
- **一貫性の欠如**: 場所によって呼び出し忘れがあると、UIの表示が不正確に

スナップショットベースの差分検出により、これらの問題を解決しました：

- **一元化**: 差分検出ロジックは`stores.ts`に集約
- **自動化**: ストア更新時（`updateNotes`、`updateLeaves`等）に自動実行
- **確実性**: 手動呼び出し不要のため、抜け漏れなし

### スナップショット変数

stores.tsにモジュールレベルの変数として、Home用とArchive用それぞれのノート・リーフの最終Push/Pull状態を保持します。

### 差分検出のタイミング

差分検出は以下の関数内で自動的に実行されます：

| 関数名              | トリガー              |
| ------------------- | --------------------- |
| updateNotes         | Homeのノート更新時    |
| updateLeaves        | Homeのリーフ更新時    |
| updateArchiveNotes  | Archiveのノート更新時 |
| updateArchiveLeaves | Archiveのリーフ更新時 |

### 検出される変更の種類

#### ノートの変更

| 変更タイプ | 検出方法                           | ダーティになるノート |
| ---------- | ---------------------------------- | -------------------- |
| 追加       | 現在にあり、スナップショットにない | 親ノート             |
| 削除       | スナップショットにあり、現在にない | 親ノート             |
| 名前変更   | `name`の比較                       | 親ノート             |
| 順序変更   | `order`の比較                      | 親ノート             |
| 移動       | `parentId`の比較                   | 元の親 + 新しい親    |

#### リーフの変更

| 変更タイプ     | 検出方法                           | ダーティになるノート | ダーティになるリーフ |
| -------------- | ---------------------------------- | -------------------- | -------------------- |
| 追加           | 現在にあり、スナップショットにない | 親ノート             | リーフ自体           |
| 削除           | スナップショットにあり、現在にない | 親ノート             | -                    |
| タイトル変更   | `title`の比較                      | 親ノート             | リーフ自体           |
| 順序変更       | `order`の比較                      | 親ノート             | リーフ自体           |
| 移動           | `noteId`の比較                     | 元の親 + 新しい親    | リーフ自体           |
| コンテンツ変更 | `content`の比較                    | -                    | リーフ自体           |

### スナップショット更新のタイミング

スナップショットは以下のタイミングで更新されます：

1. **Push成功時**: 現在の状態が「最新の同期済み状態」になる
2. **Pull成功時（Home）**: GitHubから取得した状態が「最新の同期済み状態」になる
3. **Pull成功時（Archive）**: アーカイブデータが「最新の同期済み状態」になる

### UIへの反映

ノートカードの赤丸表示は以下の2条件のいずれかで表示されます：

- 配下のリーフに変更がある（`$dirtyLeafIds.has(leafId)`）
- 構造的な変更がある（`$dirtyNoteIds.has(noteId)`）

リーフカードの赤丸表示：

- リーフに変更がある（`$dirtyLeafIds.has(leafId)`）

### パフォーマンス考慮

- **検出タイミング**: ストア更新時のみ（定期的なポーリングではない）
- **スコープ**: Home/Archiveそれぞれで独立して検出し、結果を統合
- **ディープコピー**: スナップショット保存時にJSON.parse/stringifyで参照を切る

---

## 自動Push機能

### 概要

編集後5分経過すると自動的にGitHubにPushします。これにより、PWA強制終了時のデータ損失リスクを軽減します。

### 設定値

| 定数                        | 値   | 説明         |
| --------------------------- | ---- | ------------ |
| AUTO_PUSH_INTERVAL_MS       | 5分  | Push間隔     |
| AUTO_PUSH_CHECK_INTERVAL_MS | 30秒 | チェック間隔 |

### 動作条件

自動Pushが実行される条件:

1. ブラウザタブがアクティブ（`visibilityState === 'visible'`）
2. GitHub設定済み
3. Push/Pull処理中でない
4. ダーティな変更がある（`isDirty === true`）
5. 前回Pushから5分以上経過
6. 初回Pull完了済み
7. staleでない（リモートに新しい変更がない）

### stale検出時の動作

リモートに新しい変更がある場合（他のデバイスでPushされた場合）:

1. `isStale`ストアを`true`に設定
2. Pullボタンに赤丸を表示
3. トースト通知「他のデバイスで変更があります。先にPullしてください。」
4. 自動Pushは実行しない

### Pullボタンの赤丸

stale状態の場合、Pullボタンに赤い丸印を表示してユーザーに通知します。

### 関連ストア

| ストア       | 説明                               |
| ------------ | ---------------------------------- |
| isStale      | リモートに新しい変更があるかどうか |
| lastPushTime | 最後にPush成功した時刻             |

### 動作フロー

1. 編集開始 → `updateLeaves()`で差分検出 → `dirtyLeafIds`に追加 → `isDirty = true`
2. 30秒ごとにチェック
3. 5分経過 + ダーティあり + アクティブ
4. staleチェック
   - staleでない → 自動Push実行 → `lastPushTime`更新 → `clearAllChanges()`
   - stale → `isStale = true` → Pullボタンに赤丸 → 自動Pushスキップ

### Pull後のstale解除

Pull成功時に`clearAllChanges()`と`isStale.set(false)`を実行してstale状態を解除します。

### 設計思想

- **5分間隔**: PWA強制終了（5分）より短い間隔で自動保存
- **バックグラウンド非実行**: バッテリー消費を抑制
- **staleチェック**: 他デバイスとの競合を防止
- **ユーザー透過**: 自動で保存されるため意識不要
